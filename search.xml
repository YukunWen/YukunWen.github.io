<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA["生成QR二维码"]]></title>
    <url>%2F2018%2F10%2F27%2Fjava%E7%94%9F%E6%88%90QR%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[####引言 随着二维码（QR code）的普及，越来越多的项目中会设计一些产生二维码的交互页面，以便更好地和用户互动，以及方便用户的使用，传播app等操作。那么今天就来探究一下如何在项目中快速简单的生成QR二维码。 ##一.简易版本 ###首先我们用到谷歌开源的zxing项目包，使用maven的同学可以轻易的导入。 &lt;!--QRcode--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--QRcode--&gt; ###第二步我们来编写生成简单二维码的java代码。只要有一个content的输入，能把content的内容藏到二维码中即可。那么代码如下： public class QRCodeUtil { private static final String CHARSET = "utf-8"; // 二维码尺寸 private static final int QRCODE_SIZE = 300; public static BufferedImage createImage(String content) { Hashtable&lt;EncodeHintType, Object> hints = new Hashtable&lt;EncodeHintType, Object>(); hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); hints.put(EncodeHintType.CHARACTER_SET, CHARSET); hints.put(EncodeHintType.MARGIN, 1); BitMatrix bitMatrix = null; try { bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, QRCODE_SIZE, QRCODE_SIZE, hints); } catch (WriterException e) { e.printStackTrace(); } int width = bitMatrix.getWidth(); int height = bitMatrix.getHeight(); BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); for (int x = 0; x &lt; width; x++) { for (int y = 0; y &lt; height; y++) { image.setRGB(x, y, bitMatrix.get(x, y) ? 0xFF000000 : 0xFFFFFFFF); } } return image; } } 下面我们编写controller接口去进行测试 注意：对于有些二维码是扫了即用，扫完即走那种的，这个时候就不应该产生本地的缓存暂用服务器资源。禁止缓存的方式详见代码。`java@Controller@RequestMapping(“/qr”)@Slf4jpublic class QRController { @GetMapping(value = &quot;/generate&quot;) @ResponseBody public void generateQR(@RequestParam(&quot;content&quot;)String content, HttpServletResponse response) { BufferedImage image; // 禁止图像缓存 response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expires&quot;, 0); response.setContentType(&quot;image/jpeg&quot;); image = QRCodeUtil.createImage(content); // 创建二进制的输出流 try(ServletOutputStream sos = response.getOutputStream()){ // 将图像输出到Servlet输出流中。 ImageIO.write(image, &quot;jpeg&quot;, sos); } catch (IOException e) { e.printStackTrace(); } } } ###结果 最终效果如下图1所示： ![图1.简易版本QR码生成图](https://upload-images.jianshu.io/upload_images/14043408-d97d2b4718eeb260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ##二.拓展版本 在实际中，我们常常会看见一些二维码中间会放置上企业的logo，显得更加的美观专业。接下来我们就如何在二维码中间增加图案进行说明。 ###首先 我们考虑增加两个变量，一个是插入图片的地址，一个压缩参数（主要用于过大logo情况下是否压缩） ```java // LOGO宽度 private static final int LOGO_WIDTH = 80; // LOGO高度 private static final int LOGO_HEIGHT = 80; /** * 插入LOGO * * @param source 二维码图片 * @param logoPath LOGO图片地址 * @param needCompress 是否压缩 * @throws Exception */ public static void insertImage(BufferedImage source, InputStream logoPath, boolean needCompress) { Image src = null; try { src = ImageIO.read(logoPath); } catch (IOException e) { e.printStackTrace(); } int width = src.getWidth(null); int height = src.getHeight(null); if (needCompress) { // 压缩LOGO if (width &gt; LOGO_WIDTH) { width = LOGO_WIDTH; } if (height &gt; LOGO_HEIGHT) { height = LOGO_HEIGHT; } Image image = src.getScaledInstance(width, height, Image.SCALE_SMOOTH); BufferedImage tag = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = tag.getGraphics(); // 绘制缩小后的图 g.drawImage(image, 0, 0, null); g.dispose(); src = image; } // 插入LOGO Graphics2D graph = source.createGraphics(); int x = (QRCODE_SIZE - width) / 2; int y = (QRCODE_SIZE - height) / 2; graph.drawImage(src, x, y, width, height, null); Shape shape = new RoundRectangle2D.Float(x, y, width, width, 12, 12); graph.setStroke(new BasicStroke(3f)); graph.draw(shape); graph.dispose(); } 我们只要在一中生成图片的基础上调用该方法，即可在里面插入一个Logo。 ###接着我们照样编写了controller去测试： ###结果最终我们就可以得到带有logo的二维码了，如下图3所示： ##三.总结有了谷歌的帮助，我们生成二维码是非常简单的一件事情。最后，博主有几点想提醒读者： 二维码的原理主要是依靠斜左上方的三个矩形框来进行定位，然后解析图片的黑白像素对应计算机编码的01操作。那么如果是二维码里面藏的东西过多的时候，二维码可能会很丑陋，几个定位符非常的小，里面的黑白点非常的密集。这个时候不妨尝试一下利用缓存，二维码里面只藏有简单的随机字符串，然后再根据扫描得到的字符串去请求缓存拿到真正的有用信息。(这种就是代理的思想) 在第1点的基础上，有时候二维码就是为了做登陆的，要求极高的安全性。在二维码里面藏了一下检验，防串改的字串，比如jwtToken。那么这个二维码很有可能会非常丑，遇到了不懂技术的产品，可能要你改需求。低效的沟通还不如直接拿巨头的成本给他看，直接拿微信公众平台(https://mp.weixin.qq.com/)的登陆页面二维码给他看，让对方明白**为了安全有的时候不得不牺牲美观**。3.关于中间藏匿的logo，读者可能需要根据logo的大小和二维码的复杂程度去自行调节一下。觉得本文写得还行的读者可以扫描文中postman生成的二维码关注我的github。 本文内容代码均放置到了github上，需要的读者自行获取： https://github.com/YukunWen/QRdemo]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["自定义配置文件properties与Spring boot源码启动配置文件分析（三）"]]></title>
    <url>%2F2018%2F10%2F21%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6properties%E4%B8%8ESpring%20boot%E6%BA%90%E7%A0%81%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在一二中我们分别分析了自定义的配置文件和springboot配置文件如何启动的。接下来我们就对文件启动的顺序进行一个探究。 三、配置文件优先级读取分析1.同为默认配置文件，读取顺序在二中我们还记得，其中的变量为： private static final String DEFAULT_SEARCH_LOCATIONS = “classpath:/,classpath:/config/,file:./,file:./config/“; 但是，代码中做了一个reverse的操作，即顺序应该是 ./config/application.properties,./application.properties,classpath:./config/application.properties,classpath:./application.properties 用图更能说明问题，详见图1。 2.同为自定义配置文件 启动顺序是：启动哪个模块(一般为web模块)就以哪个模块的优先。 但是其余模块顺序未知，很有可能跟module的设置顺序有关(博主未曾实验过，只是一种猜测)。但是，既然是自定义配置文件了，还是建议不要有同名的变量配置，以免给自己找麻烦。 3.自定义配置文件和默认配置文件冲突 这个时候的优先级是默认配置文件的优先级要跟高一些。 换句话说，默认配置文件会比自定义配置文件更加后启动。 4.出现多个默认的配置文件根据二中的分析，我们知道系统只会找到一份默认的配置文件，就会停止搜索。那么会先搜索哪个模块下面的配置文件。 还是跟第2点一样，会先搜索启动项目的模块，再去找其他模块。 对于其他模块的搜索顺序，还是未确定数。有兴趣的读者可以自行分析一下源码。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["自定义配置文件properties与Spring boot源码启动配置文件分析（二）"]]></title>
    <url>%2F2018%2F10%2F21%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6properties%E4%B8%8ESpring%20boot%E6%BA%90%E7%A0%81%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一篇文章说完了自定义配置文件properties的写法，并且介绍了采用classpath*通配模式下读取多个同名文件的内容方法。下面就要进入到对springboot的默认配置文件application.properties的分析了。 二、springboot读取默认配置文件深入探究1.springboot启动用运行通过run里面跟踪下去，会执行到ConfigurableApplicationContext run(String… args)里面，在里面初始化sprignboot的上下文配置。它的listern（ConfigFileApplicationListener）会对它的执行进行监听。ConfigFileApplicationListener里面存在一些static变量，我们先来看一下他们,后面都会用到。注意下面的 DEFAULT_SEARCH_LOCATIONS ，都是采用classpath:的模式，并没有带* public class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered { private static final String DEFAULT_PROPERTIES = "defaultProperties"; // Note the order is from least to most specific (last one wins) private static final String DEFAULT_SEARCH_LOCATIONS = "classpath:/,classpath:/config/,file:./,file:./config/"; private static final String DEFAULT_NAMES = "application"; ... /** * The "config location" property name. */ public static final String CONFIG_LOCATION_PROPERTY = "spring.config.location"; /** * The "config additional location" property name. */ public static final String CONFIG_ADDITIONAL_LOCATION_PROPERTY = "spring.config.additional-location"; ... } 调用到ConfigFileApplicationListener 里面的addLoadedPropertySources(ConfigurableEnvironment environment,ResourceLoader resourceLoader)，该方法内部会初始化Loader对象，调用load()函数。下面进入正文——我们来详细看一下load()函数 public void load() { this.profiles = new LinkedList&lt;>(); this.processedProfiles = new LinkedList&lt;>(); this.activatedProfiles = false; this.loaded = new LinkedHashMap&lt;>(); initializeProfiles(); while (!this.profiles.isEmpty()) { Profile profile = this.profiles.poll(); if (profile != null &amp;&amp; !profile.isDefaultProfile()) { addProfileToEnvironment(profile.getName()); } load(profile, this::getPositiveProfileFilter, addToLoaded(MutablePropertySources::addLast, false)); this.processedProfiles.add(profile); } load(null, this::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, true)); addLoadedPropertySources(); } 可以发现里面profiles.poll()一开始为空，所以会调用 load(profile, this::getPositiveProfileFilter, addToLoaded(MutablePropertySources::addLast, false)); 2.真正读取的地方首先来看一下load源码 private void load(Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) { getSearchLocations().forEach((location) -> { boolean isFolder = location.endsWith("/"); Set&lt;String> names = isFolder ? getSearchNames() : NO_SEARCH_NAMES; names.forEach( (name) -> load(location, name, profile, filterFactory, consumer)); }); } 3. 先调用getSearchLocations()方法接着相应的搜索地方调用查找位置，除非配置了spring.config.location private Set&lt;String> getSearchLocations() { if (this.environment.containsProperty(CONFIG_LOCATION_PROPERTY)) { return getSearchLocations(CONFIG_LOCATION_PROPERTY); } Set&lt;String> locations = getSearchLocations( CONFIG_ADDITIONAL_LOCATION_PROPERTY); locations.addAll( asResolvedSet(ConfigFileApplicationListener.this.searchLocations, DEFAULT_SEARCH_LOCATIONS)); return locations; } 3.1继续进入其中的asResolvedSet()方法这里面做了一个reverse操作 private Set&lt;String> asResolvedSet(String value, String fallback) { List&lt;String> list = Arrays.asList(StringUtils.trimArrayElements( StringUtils.commaDelimitedListToStringArray((value != null) ? this.environment.resolvePlaceholders(value) : fallback))); Collections.reverse(list); return new LinkedHashSet&lt;>(list); } 4. 接着我们来看 getSearchNames()方法操作都差不多，大同小异，先看下有没有设置别名，没有的话就采用默认的application名称 private Set&lt;String> getSearchNames() { if (this.environment.containsProperty(CONFIG_NAME_PROPERTY)) { String property = this.environment.getProperty(CONFIG_NAME_PROPERTY); return asResolvedSet(property, null); } return asResolvedSet(ConfigFileApplicationListener.this.names, DEFAULT_NAMES); } 5. 最后我们来看一下foreach里面的load方法如果找得到name(即上面默认情况下的application，或者自定义名称)的情况下，就进行相应的配置文件的读取 private void load(String location, String name, Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) { if (!StringUtils.hasText(name)) { for (PropertySourceLoader loader : this.propertySourceLoaders) { if (canLoadFileExtension(loader, location)) { load(loader, location, profile, filterFactory.getDocumentFilter(profile), consumer); return; } } } Set&lt;String> processed = new HashSet&lt;>(); for (PropertySourceLoader loader : this.propertySourceLoaders) { for (String fileExtension : loader.getFileExtensions()) { if (processed.add(fileExtension)) { loadForFileExtension(loader, location + name, "." + fileExtension, profile, filterFactory, consumer); } } } } 5.1 继续进入第一个if的load()方法别看这段代码长，实际上就是try里面的第一句有用，后面都是一些情况判断 private void load(PropertySourceLoader loader, String location, Profile profile, DocumentFilter filter, DocumentConsumer consumer) { try { Resource resource = this.resourceLoader.getResource(location); if (resource == null || !resource.exists()) { if (this.logger.isTraceEnabled()) { this.logger.trace("Skipped missing config " + getDescription(location, resource, profile)); } return; } if (!StringUtils.hasText( StringUtils.getFilenameExtension(resource.getFilename()))) { if (this.logger.isTraceEnabled()) { this.logger.trace("Skipped empty config extension " + getDescription(location, resource, profile)); } return; } String name = "applicationConfig: [" + location + "]"; List&lt;Document> documents = loadDocuments(loader, name, resource); if (CollectionUtils.isEmpty(documents)) { if (this.logger.isTraceEnabled()) { this.logger.trace("Skipped unloaded config " + getDescription(location, resource, profile)); } return; } List&lt;Document> loaded = new ArrayList&lt;>(); for (Document document : documents) { if (filter.match(document)) { addActiveProfiles(document.getActiveProfiles()); addIncludedProfiles(document.getIncludeProfiles()); loaded.add(document); } } Collections.reverse(loaded); if (!loaded.isEmpty()) { loaded.forEach((document) -> consumer.accept(profile, document)); if (this.logger.isDebugEnabled()) { this.logger.debug("Loaded config file " + getDescription(location, resource, profile)); } } } catch (Exception ex) { throw new IllegalStateException("Failed to load property " + "source from location '" + location + "'", ex); } } 5.2 与自定义配置文件相连自此，就和前面的给串联起来了。getResource因为不是classpath*模式，所以会走到上面代码的最后一个else // a single resource with the given name return new Resource[] {getResourceLoader().getResource(locationPattern)}; 而getResourceLoader().getResource(locationPattern)最后返回的是一个Resource对象，所以对于Resource[]中只会有一个对象存在。 5.3我们在进一步查看它的实现类public interface ResourceLoader { /** Pseudo URL prefix for loading from the class path: "classpath:" */ String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; /** * Return a Resource handle for the specified resource location. * &lt;p>The handle should always be a reusable resource descriptor, * allowing for multiple {@link Resource#getInputStream()} calls. * &lt;p>&lt;ul> * &lt;li>Must support fully qualified URLs, e.g. "file:C:/test.dat". * &lt;li>Must support classpath pseudo-URLs, e.g. "classpath:test.dat". * &lt;li>Should support relative file paths, e.g. "WEB-INF/test.dat". * (This will be implementation-specific, typically provided by an * ApplicationContext implementation.) * &lt;/ul> * &lt;p>Note that a Resource handle does not imply an existing resource; * you need to invoke {@link Resource#exists} to check for existence. * @param location the resource location * @return a corresponding Resource handle (never {@code null}) * @see #CLASSPATH_URL_PREFIX * @see Resource#exists() * @see Resource#getInputStream() */ Resource getResource(String location); 进一步看它的实现类，如果是for循环里面找到一个值，就会返回 @Override public Resource getResource(String location) { Assert.notNull(location, "Location must not be null"); for (ProtocolResolver protocolResolver : this.protocolResolvers) { Resource resource = protocolResolver.resolve(location, this); if (resource != null) { return resource; } } if (location.startsWith("/")) { return getResourceByPath(location); } else if (location.startsWith(CLASSPATH_URL_PREFIX)) { return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); } else { try { // Try to parse the location as a URL... URL url = new URL(location); return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); } catch (MalformedURLException ex) { // No URL -> resolve as resource path. return getResourceByPath(location); } } } public ClassPathResource(String path, @Nullable ClassLoader classLoader) { Assert.notNull(path, "Path must not be null"); String pathToUse = StringUtils.cleanPath(path); if (pathToUse.startsWith("/")) { pathToUse = pathToUse.substring(1); } this.path = pathToUse; this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader()); } 6. 当读取完后会回到 1 下面的执行最后的加载参数 addLoadedPropertySources(); 总结:对于classpath模式会全局查找多处结果合并，而classpath只要找到一个就停止了。所以采用默认模块下面的配置文件，application.properties，在单项目多模块下，记得要在web模块（即启动模块）下放置**一个**就好了。这样一方面便于管理，一方面也不会出现重复覆盖的问题。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["自定义配置文件properties与Spring boot源码启动配置文件分析（一）"]]></title>
    <url>%2F2018%2F10%2F20%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6properties%E4%B8%8ESpring%20boot%E6%BA%90%E7%A0%81%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[引言springboot项目默认启动的是application.properties文件。在实际的开发中，一个项目中会含有多个模块，每个模块下面可能都含有一个或多个默认的配置信息。另外，有的工程中可能会需要引入额外的自定义配置文件。由此，引出三个问题： 1. 自定义配置文件如何书写？2. 默认的配置文件启动的顺序与读取？3. 自定义配置文件与默认配置文件发生冲突的时候谁的优先级更高？ 下面我们将仔细的分析三个问题的实现与原理 一、自定义配置文件1.1自定义配置文件书写先上例子，整个项目的架构是parent下面多个模块，每个模块里面可能会有一些自定的参数，又不想集中全部写在application.properties中，这样会默认配置会显得繁琐，难以查找与修改。所以我们在不同的架构下会创建一个自定义的配置文件，名为fantuan.properties。对于这种额外自定义的配置，肯定要求多个模块下面都要生效。于是，源码要采用classpath*模式，具体代码如下： @Configuration public class FantuanPropertiesConfig { @Bean public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer( ApplicationContext applicationContext) throws IOException { Resource[] resources = applicationContext.getResources("classpath*:fantuan.properties"); PropertyPlaceholder placeholder = new PropertyPlaceholder(); ArrayUtils.reverse(resources); placeholder.setResources(resources); return placeholder; } } public class PropertyPlaceholder extends PropertySourcesPlaceholderConfigurer { @Setter private Resource[] resources; @Override protected void loadProperties(Properties props) throws IOException { super.loadProperties(props); for (Resource resource : resources) { PropertiesLoaderUtils.fillProperties(props, new EncodedResource(resource, "utf-8")); } } } 让我们进一步来看一下springboot中的getResources()源码： //在spring-core-5.0.8的jar包下面的org.springframework.core.io.support 的 PathMatchingResourcePatternResolver 类 @Override public Resource[] getResources(String locationPattern) throws IOException { Assert.notNull(locationPattern, "Location pattern must not be null"); if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) { // a class path resource (multiple resources for same name possible) if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) { // a class path resource pattern return findPathMatchingResources(locationPattern); } else { // all class path resources with the given name return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); } } else { // Generally only look for a pattern after a prefix here, // and on Tomcat only after the "*/" separator for its "war:" protocol. int prefixEnd = (locationPattern.startsWith("war:") ? locationPattern.indexOf("*/") + 1 : locationPattern.indexOf(':') + 1); if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) { // a file pattern return findPathMatchingResources(locationPattern); } else { // a single resource with the given name return new Resource[] {getResourceLoader().getResource(locationPattern)}; } } } 其中CLASSPATH_ALL_URL_PREFIX为： public interface ResourcePatternResolver extends ResourceLoader { /** * Pseudo URL prefix for all matching resources from the class path: "classpath*:" * This differs from ResourceLoader's classpath URL prefix in that it * retrieves all matching resources for a given name (e.g. "/beans.xml"), * for example in the root of all deployed JAR files. * @see org.springframework.core.io.ResourceLoader#CLASSPATH_URL_PREFIX */ String CLASSPATH_ALL_URL_PREFIX = "classpath*:"; ··· } 由此可见，只要是classpath*这样子的写法，就会是多匹配模式，即便是同名的也会多包含模式。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["爬虫抓取重定向问题"]]></title>
    <url>%2F2018%2F10%2F20%2F%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在做爬虫中，我们经常会遇到重定向问题。比如之前做的秒拍的地址： http://www.miaopai.com/show/5bpIqSpDFRAvlgidhXSTKZkfSwWYpwaV5SI1ZA__.htm 在重定向后就成为了： http://n.miaopai.com/media/fnrDABcheGpX2nrnpts7J9KC5ZlnVZ~Z 从浏览器的network也可以看出来发生了一个重定向 所以如果我们直接请求原地址，并且用页面解析方法（如jsoup等），就无法获取到相应的视频标题，视频源码地址等信息。 那么，就需要我们在该地址之前做一层302重定向到新的地址，根据新的地址就可以进行原有的解析工作。 网上查到有一种简单的方法： String url = "http://www.miaopai.com/show/5bpIqSpDFRAvlgidhXSTKZkfSwWYpwaV5SI1ZA__.htm"; System.out.println("访问地址:" + url); URL serverUrl = new URL(url); HttpURLConnection conn = (HttpURLConnection) serverUrl.openConnection(); conn.setRequestMethod("GET"); conn.setRequestProperty("accept", "*/*"); conn.setRequestProperty("connection", "Keep-Alive"); // 必须设置false，否则会自动redirect到Location的地址 conn.setInstanceFollowRedirects(false); //获取Location地址 String location = conn.getHeaderField("Location"); System.out.println(location); 该方法在本地进行模拟还可以，但是不适用于在生产上。实际生产中爬虫都是高频次的爬取，所以任何的访问都必须带上代理才行。结合公司目前采用的是httpClient框架，于是给出如下demo代码。 含有代理的httpClient实现： public static List&lt;URI> doGetRedirectLocations(HttpGet httpReq){ setHeaders(httpReq); httpReq.setConfig(instance.reqConfig); HttpClientContext localContext = getProxyContext(); try (CloseableHttpResponse httpResp = instance.httpClient.execute(httpReq, localContext)){ return localContext.getRedirectLocations(); } catch (Exception e) { throw new RuntimeException(e); } } public static HttpClientContext getProxyContext() { AuthCache authCache = new BasicAuthCache(); authCache.put(instance.proxy, new BasicScheme()); HttpClientContext localContext = HttpClientContext.create(); localContext.setAuthCache(authCache); return localContext; } 更进一步地，由于大型网站都会有防爬虫的机制，即便你采用了动态IP的代理，但是还是难免在抓取的过程中可能会弹出需要输入验证码，或者进行滑块滑动验证的时候。于是，更进一步的代码如下。 增加轮询的视频抓取： public static List&lt;URI> doGetRedirectLocations(HttpGet httpReq, int retry) { if (retry == 0) { log.error("重试次数已经用完" + httpReq); return null; } HttpClientContext localContext = getProxyContext(); try (CloseableHttpResponse httpResp = instance.httpClient.execute(httpReq, localContext)) { List&lt;URI> redirectLocations = localContext.getRedirectLocations(); if (redirectLocations != null &amp;&amp; redirectLocations.size() > 0) { return redirectLocations; } else { Thread.sleep(1000); return doGetRedirectLocations(httpReq, retry - 1); } } catch (Exception e) { throw new RuntimeException(e); } } PS: 轮询有多重实现方式，初级工程师基本会使用for循环，那样的代码有时候冗余，可读性差。轮询最好用递归的方式，显得优雅。 至此，关于视频重定向的问题就这么解决了。最后顺口提及一句，在做爬虫解析过程中，我们发现了很多时候URL的尾部是非常不重要的。比如，本文章中的秒拍地址： http://www.miaopai.com/show/5bpIqSpDFRAvlgidhXSTKZkfSwWYpwaV5SI1ZA__.htm 你就算是写成 http://www.miaopai.com/show/5bpIqSpDFRAvlgidhXSTKZkfSwWYpwaV5SI1ZA__.html 或者 http://www.miaopai.com/show/5bpIqSpDFRAvlgidhXSTKZkfSwWYpwaV5SI1ZA__ 一样可以无差别访问，因此在做正则匹配的时候，切记考虑通配尾部。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["linux上发送邮件"]]></title>
    <url>%2F2018%2F10%2F14%2Flinux%E4%B8%8A%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[####1. 首先需要安装mailx yum install mailx ####2. 编辑配置文件 vim /etc/mail.rc 添加如下内容 //from：对方收到邮件时显示的发件人 set from=xxxx@qq.com //smtp：指定第三方发邮件的smtp服务器地址 set smtp=smtp.qq.com //smtp-auth-user：第三方发邮件的用户名 set smtp-auth-user=xx@qq.com //smtp-auth-password：用户名对应的密码,有些邮箱填的是授权码 set smtp-auth-password=xxx //smtp-auth：SMTP的认证方式，默认是login，也可以改成CRAM-MD5或PLAIN方式 set smtp-auth=login ####3. 测试 mail -s “hello word” xxxx@qq.com &lt; /etc/passwdecho “测试邮件” | mail -s “测试” xx@qq.com 另外注意smtp协议要求服务器25端口是开通的，如果是购买vultr服务器的，需要另外向供应方去申请端口。国外的防止垃圾邮件规则非常麻烦，作者在申请的时候就需要等待14天的考察期，没问题后才被开启。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
